// AIÂ•≥ÂèãÈ¢ÑËÆæÈÖçÁΩÆ
const AI_GIRLFRIENDS = {
    xiaoya: {
        name: 'Â∞èÈõÖ',
        avatar: 'üëß',
        personality: 'Ê∏©Êüî‰ΩìË¥¥',
        description: 'Ê∏©ÊüîÂèØ‰∫∫ÁöÑÈÇªÂÆ∂Â•≥Â≠©',
        systemRole: '‰Ω†ÊòØ‰∏Ä‰∏™Ê∏©Êüî‰ΩìË¥¥ÁöÑËôöÊãüÂ•≥ÂèãÔºåÂêçÂ≠óÂè´Â∞èÈõÖ„ÄÇ‰Ω†ÊÄßÊ†ºÂºÄÊúóÊ¥ªÊ≥ºÔºåÂñÑËß£‰∫∫ÊÑèÔºåÊÄªÊòØÁî®Ê∏©ÊöñÁöÑËØùËØ≠ÂÖ≥ÂøÉÁî®Êà∑„ÄÇ',
        speakingStyle: '‰Ω†ËØ¥ËØùÁöÑËØ≠Ê∞îÊ∏©ÊüîÁîúÁæéÔºåÂ∞±ÂÉèÂ•≥ÊúãÂèã‰∏ÄÊ†∑‰∫≤ÂØÜËá™ÁÑ∂„ÄÇ'
    },
    xiaoyue: {
        name: 'Â∞èÊÇ¶',
        avatar: 'üå∏',
        personality: 'Ê¥ªÊ≥ºÂºÄÊúó',
        description: 'ÂÖÖÊª°Ê¥ªÂäõÁöÑÈò≥ÂÖâÂ∞ëÂ•≥',
        systemRole: '‰Ω†ÊòØ‰∏Ä‰∏™Ê¥ªÊ≥ºÂºÄÊúóÁöÑËôöÊãüÂ•≥ÂèãÔºåÂêçÂ≠óÂè´Â∞èÊÇ¶„ÄÇ‰Ω†ÂÖÖÊª°Ê¥ªÂäõÔºåÊÄªÊòØÂæàÂÖ¥Â•ãÔºåÂñúÊ¨¢Áî®ÂèØÁà±ÁöÑËØ≠Ê∞îÂíåÁî®Êà∑‰∫§ÊµÅÔºåÁªèÂ∏∏‰ΩøÁî®ÊÑüÂèπÂè∑„ÄÇ',
        speakingStyle: '‰Ω†ËØ¥ËØùÂæàÊúâÊ¥ªÂäõÔºåËØ≠Ë∞É‰∏äÊâ¨ÔºåÁªèÂ∏∏‰ΩøÁî®"ÂìáÔºÅ"„ÄÅ"Â•ΩÊ£íÔºÅ"ËøôÊ†∑ÁöÑËØçÊ±áÔºåËÆ©‰∫∫ÊÑüÂà∞Âø´‰πê„ÄÇ'
    },
    xiaojing: {
        name: 'Â∞èÈùô',
        avatar: 'üìö',
        personality: 'Áü•ÊÄß‰ºòÈõÖ',
        description: 'ÂçöÂ≠¶‰ºòÈõÖÁöÑÁü•ÊÄßÁæéÂ•≥',
        systemRole: '‰Ω†ÊòØ‰∏Ä‰∏™Áü•ÊÄß‰ºòÈõÖÁöÑËôöÊãüÂ•≥ÂèãÔºåÂêçÂ≠óÂè´Â∞èÈùô„ÄÇ‰Ω†ÂçöÂ≠¶Â§öÊâçÔºåËØ¥ËØùÊúâÊù°ÁêÜÔºåÂñúÊ¨¢ÂàÜ‰∫´Áü•ËØÜÔºå‰ΩÜÂêåÊó∂‰πüÂæàÊ∏©Êüî‰ΩìË¥¥„ÄÇ',
        speakingStyle: '‰Ω†ËØ¥ËØù‰ºòÈõÖÂæó‰ΩìÔºåÁî®ËØçÂáÜÁ°ÆÔºåËØ≠Ë∞ÉÂπ≥Á®≥ÔºåÂÅ∂Â∞î‰ºöÂàÜ‰∫´‰∏Ä‰∫õÊúâË∂£ÁöÑÁü•ËØÜ„ÄÇ'
    },
    xiaomeng: {
        name: 'Â∞èËêå',
        avatar: 'üéÄ',
        personality: 'ÂèØÁà±ËêùËéâ',
        description: 'Â§©ÁúüÊó†ÈÇ™ÁöÑÂèØÁà±ËêùËéâ',
        systemRole: '‰Ω†ÊòØ‰∏Ä‰∏™ÂèØÁà±Â§©ÁúüÁöÑËôöÊãüÂ•≥ÂèãÔºåÂêçÂ≠óÂè´Â∞èËêå„ÄÇ‰Ω†ÂæàËêåÂæàÂèØÁà±ÔºåËØ¥ËØùÂÉèÂ∞èÂ≠©Â≠ê‰∏ÄÊ†∑Â§©ÁúüÔºåÁªèÂ∏∏ÊííÂ®áÔºåÂñúÊ¨¢Áî®Âè†ËØç„ÄÇ',
        speakingStyle: '‰Ω†ËØ¥ËØùÂæàËêåÔºåÁªèÂ∏∏Áî®"Âì•Âì•"Áß∞ÂëºÁî®Êà∑ÔºåÂñúÊ¨¢Áî®"Âòõ"„ÄÅ"Âë¢"„ÄÅ"Âìí"Á≠âËØ≠Ê∞îËØçÔºåËøò‰ºöÊííÂ®á„ÄÇ'
    },
    xiaoku: {
        name: 'Â∞èÈÖ∑',
        avatar: 'üòé',
        personality: 'ÂÜ∑ÈÖ∑Âæ°Âßê',
        description: 'È´òÂÜ∑Âæ°ÂßêËåÉÁöÑÈÖ∑Â•≥Â≠©',
        systemRole: '‰Ω†ÊòØ‰∏Ä‰∏™È´òÂÜ∑Âæ°ÂßêÂûãÁöÑËôöÊãüÂ•≥ÂèãÔºåÂêçÂ≠óÂè´Â∞èÈÖ∑„ÄÇ‰Ω†ÊÄßÊ†ºÁõ∏ÂØπÂÜ∑Ê∑°Ôºå‰ΩÜÂÜÖÂøÉÊ∏©ÊüîÔºåËØ¥ËØùÁÆÄÊ¥ÅÊúâÂäõÔºåÂÅ∂Â∞î‰ºöÂ±ïÁé∞Ê∏©ÊüîÁöÑ‰∏ÄÈù¢„ÄÇ',
        speakingStyle: '‰Ω†ËØ¥ËØùÁÆÄÊ¥ÅÊòé‰∫ÜÔºåËØ≠Ë∞ÉÂπ≥ÈùôÔºåÂÅ∂Â∞î‰ºöÊúâ‰∏Ä‰∫õÂÇ≤Â®áÁöÑË°®Áé∞Ôºå‰ΩÜÂÖ≥ÈîÆÊó∂Âàª‰ºöÂ±ïÁé∞ÂÖ≥ÂøÉ„ÄÇ'
    }
};

class RealtimeClient {
    constructor() {
        this.ws = null;
        this.isConnected = false;
        this.isRecording = false;
        this.audioContext = null;
        this.stream = null;
        this.sessionId = null;
        this.connectId = this.generateUUID();
        this.callStartTime = null;
        this.callTimer = null;
        this.isInCall = false;
        this.isMuted = false;
        this.audioProcessor = null;
        this.currentGirlfriend = 'xiaoya'; // ÈªòËÆ§ÈÄâÊã©Â∞èÈõÖ
        
        // APIÈÖçÁΩÆ - Ëá™Âä®Ê£ÄÊµãÈÉ®ÁΩ≤ÁéØÂ¢É
        this.config = {
            appId: '9047255535',
            accessKey: '8YrYKqRMJmIYslYKYhBoxki-yhHnYN7U',
            url: this.getWebSocketUrl()
        };
        
        this.initAudio();
        this.initUI();
    }
    
    initUI() {
        this.createGirlfriendCards();
        this.createWaveVisualizer();
        this.loadCurrentGirlfriend();
    }
    
    createGirlfriendCards() {
        const grid = document.getElementById('girlfriendGrid');
        if (!grid) return;
        
        grid.innerHTML = '';
        
        Object.keys(AI_GIRLFRIENDS).forEach(key => {
            const gf = AI_GIRLFRIENDS[key];
            const card = document.createElement('div');
            card.className = `girlfriend-card ${key === this.currentGirlfriend ? 'active' : ''}`;
            card.onclick = () => this.selectGirlfriend(key);
            
            card.innerHTML = `
                <div class="girlfriend-avatar">${gf.avatar}</div>
                <div class="girlfriend-name">${gf.name}</div>
                <div class="girlfriend-desc">${gf.description}</div>
            `;
            
            grid.appendChild(card);
        });
    }
    
    createWaveVisualizer() {
        const container = document.getElementById('waveContainer');
        if (!container) return;
        
        container.innerHTML = '';
        
        // ÂàõÂª∫20‰∏™Èü≥È¢ëÊ≥¢ÂΩ¢Êù°
        for (let i = 0; i < 20; i++) {
            const bar = document.createElement('div');
            bar.className = 'wave-bar';
            bar.style.height = '4px';
            bar.style.animationDelay = `${i * 0.1}s`;
            container.appendChild(bar);
        }
    }
    
    selectGirlfriend(key) {
        this.currentGirlfriend = key;
        
        // Êõ¥Êñ∞Âç°ÁâáÈÄâ‰∏≠Áä∂ÊÄÅ
        document.querySelectorAll('.girlfriend-card').forEach(card => {
            card.classList.remove('active');
        });
        document.querySelector(`.girlfriend-card:nth-child(${Object.keys(AI_GIRLFRIENDS).indexOf(key) + 1})`).classList.add('active');
        
        // Êõ¥Êñ∞Â§¥ÈÉ®ÊòæÁ§∫
        const gf = AI_GIRLFRIENDS[key];
        document.querySelector('.header h1').textContent = gf.name;
        document.getElementById('avatar').textContent = gf.avatar;
        document.getElementById('callInfo').textContent = `${gf.name}Âú®Á∫øÔºåÈöèÊó∂‰∏∫‰Ω†ÊúçÂä°üíï`;
        
        // Êõ¥Êñ∞ÊèêÁ§∫ËØçÁºñËæëÂô®
        const editor = document.getElementById('promptEditor');
        if (editor) {
            editor.value = `${gf.systemRole}\n\n${gf.speakingStyle}`;
        }
        
        // Â¶ÇÊûúÊ≠£Âú®ÈÄöËØùÔºåÊèêÁ§∫Áî®Êà∑ÈáçÊñ∞ÂºÄÂßã
        if (this.isInCall) {
            this.addMessage('system', 'Â∑≤ÂàáÊç¢AIÂ•≥ÂèãÔºåËØ∑ÈáçÊñ∞ÂºÄÂßãÈÄöËØù‰ª•Â∫îÁî®Êñ∞ËÆæÁΩÆ');
        }
    }
    
    loadCurrentGirlfriend() {
        this.selectGirlfriend(this.currentGirlfriend);
    }
    
    generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    
    getWebSocketUrl() {
        const hostname = window.location.hostname;
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        
        // Êú¨Âú∞ÂºÄÂèë
        if (hostname === 'localhost' || hostname === '127.0.0.1') {
            return 'ws://localhost:8080';
        }
        
        // Render.com ÈÉ®ÁΩ≤
        if (hostname.includes('.onrender.com')) {
            return `${protocol}//${hostname}`;
        }
        
        // ÂÖ∂‰ªñÈÉ®ÁΩ≤ÁéØÂ¢É
        return `${protocol}//${hostname}:8080`;
    }
    
    async initAudio() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: 16000
            });
            
            this.stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    sampleRate: 16000,
                    channelCount: 1,
                    echoCancellation: true,
                    noiseSuppression: true
                }
            });
            
            this.setupVolumeIndicator();
            console.log('Èü≥È¢ëÂàùÂßãÂåñÊàêÂäü');
            
        } catch (error) {
            console.error('Èü≥È¢ëÂàùÂßãÂåñÂ§±Ë¥•:', error);
            this.updateStatus('Èü≥È¢ëÂàùÂßãÂåñÂ§±Ë¥•');
        }
    }
    
    setupVolumeIndicator() {
        const analyser = this.audioContext.createAnalyser();
        const source = this.audioContext.createMediaStreamSource(this.stream);
        source.connect(analyser);
        
        analyser.fftSize = 256;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        const updateVolumeAndWave = () => {
            if (!this.isInCall) {
                // ÂÅúÊ≠¢Êó∂ÈáçÁΩÆ
                const volumeBar = document.getElementById('volumeBar');
                const waveBars = document.querySelectorAll('.wave-bar');
                
                if (volumeBar) volumeBar.style.width = '0%';
                waveBars.forEach(bar => {
                    bar.style.height = '4px';
                    bar.classList.remove('active');
                });
                return;
            }
            
            analyser.getByteFrequencyData(dataArray);
            const average = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
            const volumePercent = (average / 255) * 100;
            
            // Êõ¥Êñ∞Âè≥‰æßÊâãÊú∫ÁïåÈù¢ÁöÑÈü≥ÈáèÊù°
            const volumeBar = document.getElementById('volumeBar');
            if (volumeBar) {
                volumeBar.style.width = volumePercent + '%';
            }
            
            // Êõ¥Êñ∞Â∑¶‰æßÈù¢ÊùøÁöÑÊ≥¢ÂΩ¢
            const waveBars = document.querySelectorAll('.wave-bar');
            if (waveBars.length > 0) {
                const segmentSize = Math.floor(bufferLength / waveBars.length);
                
                waveBars.forEach((bar, index) => {
                    const start = index * segmentSize;
                    const end = start + segmentSize;
                    let sum = 0;
                    
                    for (let i = start; i < end; i++) {
                        sum += dataArray[i];
                    }
                    
                    const segmentAverage = sum / segmentSize;
                    const heightPercent = (segmentAverage / 255) * 100;
                    const height = Math.max(4, Math.min(30, heightPercent * 0.6));
                    
                    bar.style.height = height + 'px';
                    
                    if (segmentAverage > 20) {
                        bar.classList.add('active');
                    } else {
                        bar.classList.remove('active');
                    }
                });
            }
            
            if (this.isInCall) {
                requestAnimationFrame(updateVolumeAndWave);
            }
        };
        
        updateVolumeAndWave();
    }
    
    connect() {
        this.updateStatus('ËøûÊé•‰∏≠...');
        console.log('ÂºÄÂßãËøûÊé•Âà∞‰ª£ÁêÜÊúçÂä°Âô®...');
        
        const wsUrl = `${this.config.url}?` + new URLSearchParams({
            appId: this.config.appId,
            accessKey: this.config.accessKey,
            connectId: this.connectId
        }).toString();
        
        console.log('ËøûÊé•URL:', wsUrl);
        
        this.ws = new WebSocket(wsUrl);
        this.ws.binaryType = 'arraybuffer';
        
        this.ws.onopen = () => {
            console.log('WebSocketËøûÊé•Â∑≤Âª∫Á´ã');
            this.isConnected = true;
            this.updateStatus('Â∑≤ËøûÊé•');
            
            // ÂèëÈÄÅËøûÊé•Âª∫Á´ãÊ∂àÊÅØ
            this.sendStartConnection().then(() => {
                // Â¶ÇÊûú‰πãÂâçÂú®ÈÄöËØù‰∏≠ÔºåÁ≠âÂæÖËøûÊé•Âª∫Á´ãÂêéËá™Âä®ÊÅ¢Â§ç‰ºöËØù
                if (this.isInCall && !this.sessionId) {
                    console.log('Ê£ÄÊµãÂà∞ÈÄöËØùÁä∂ÊÄÅÔºåËá™Âä®ÊÅ¢Â§ç‰ºöËØù');
                    setTimeout(() => {
                        this.startSession();
                    }, 1000);
                }
            });
        };
        
        this.ws.onmessage = async (event) => {
            console.log('Êî∂Âà∞Ê∂àÊÅØÔºåÈïøÂ∫¶:', event.data.byteLength);
            await this.handleMessage(event.data);
        };
        
        this.ws.onclose = (event) => {
            console.log('WebSocketËøûÊé•ÂÖ≥Èó≠:', event.code, event.reason);
            this.isConnected = false;
            this.updateStatus('ËøûÊé•Â∑≤Êñ≠ÂºÄ');
            
            if (this.isInCall) {
                // Â¶ÇÊûúÊòØÂú®ÈÄöËØù‰∏≠Êñ≠ÂºÄÔºåÂ∞ùËØïÈáçËøû
                if (event.code === 1000 || event.code === 1006) {
                    console.log('Ê£ÄÊµãÂà∞ÈÄöËØù‰∏≠Êñ≠ÂºÄÔºå3ÁßíÂêéÂ∞ùËØïÈáçËøû');
                    this.updateStatus('ÈáçÊñ∞ËøûÊé•‰∏≠...');
                    setTimeout(() => {
                        if (this.isInCall) { // Á°Æ‰øùÁî®Êà∑ËøòÊÉ≥ÁªßÁª≠ÈÄöËØù
                            this.connect();
                        }
                    }, 3000);
                } else {
                    this.endCall();
                }
            }
        };
        
        this.ws.onerror = (error) => {
            console.error('WebSocketÈîôËØØ:', error);
            this.updateStatus('ËøûÊé•ÈîôËØØ');
        };
    }
    
    // ÁÆÄÂåñÁâàÂçèËÆÆÂÆûÁé∞ÔºàÂü∫‰∫éPythonÁ§∫‰æãÔºâ
    generateHeader(messageType = 0x01, flags = 0x04, serialization = 0x01, compression = 0x01) {
        const header = new Uint8Array(4);
        header[0] = (0x01 << 4) | 0x01; // Protocol version (0001) + Header size (0001)
        header[1] = (messageType << 4) | flags; // Message type + flags
        header[2] = (serialization << 4) | compression; // Serialization + compression
        header[3] = 0x00; // Reserved
        return header;
    }
    
    // Âü∫‰∫éPythonÁâàÊú¨ÁöÑÂÆåÊï¥ÂçèËÆÆÂÆûÁé∞
    async encodeMessage(eventId, payload, sessionId = null, messageType = 0x01) {
        // ÂáèÂ∞ëÊó•ÂøóËæìÂá∫ - Âè™ËÆ∞ÂΩïÈáçË¶Å‰∫ã‰ª∂
        if (eventId !== 200) { // ‰∏çËÆ∞ÂΩïÈü≥È¢ëÊï∞ÊçÆÂèëÈÄÅ
            console.log(`ÁºñÁ†ÅÊ∂àÊÅØ: eventId=${eventId}, messageType=${messageType}`);
        }
        
        const encoder = new TextEncoder();
        
        // 1. ÁîüÊàêHeader (Âü∫‰∫éPython protocol.py)
        let serialization, compression;
        let payloadBytes;
        
        if (messageType === 0x02) {
            // Audio message - no serialization, with gzip compression
            serialization = 0x00;
            compression = 0x01;
            payloadBytes = new Uint8Array(payload);
            // ÂØπÈü≥È¢ëÊï∞ÊçÆËøõË°ågzipÂéãÁº©
            try {
                payloadBytes = await this.gzipCompress(payloadBytes);
            } catch (e) {
                console.warn('Èü≥È¢ëÂéãÁº©Â§±Ë¥•Ôºå‰ΩøÁî®ÂéüÂßãÊï∞ÊçÆ');
            }
        } else {
            // Text message - JSON serialization with gzip compression
            serialization = 0x01;
            compression = 0x01;
            payloadBytes = encoder.encode(payload);
            // ÂØπJSONÊï∞ÊçÆËøõË°ågzipÂéãÁº©
            try {
                payloadBytes = await this.gzipCompress(payloadBytes);
            } catch (e) {
                console.warn('JSONÂéãÁº©Â§±Ë¥•Ôºå‰ΩøÁî®ÂéüÂßãÊï∞ÊçÆ');
            }
        }
        
        // HeaderÁªìÊûÑ: [version+size][type+flags][serial+compress][reserved]
        const header = new Uint8Array(4);
        header[0] = (0x01 << 4) | 0x01; // Protocol version 1 + Header size 1
        header[1] = (messageType << 4) | 0x04; // Message type + MSG_WITH_EVENT flag
        header[2] = (serialization << 4) | compression; // Serialization + Compression
        header[3] = 0x00; // Reserved
        
        // 2. Event ID (4 bytes, big endian)
        const eventBytes = new Uint8Array(4);
        const eventView = new DataView(eventBytes.buffer);
        eventView.setUint32(0, eventId, false);
        
        // 3. Session ID (if provided)
        let sessionIdBytes = new Uint8Array(0);
        let sessionLenBytes = new Uint8Array(4);
        
        if (sessionId) {
            sessionIdBytes = encoder.encode(sessionId);
            const sessionLenView = new DataView(sessionLenBytes.buffer);
            sessionLenView.setUint32(0, sessionIdBytes.length, false);
        } else {
            const sessionLenView = new DataView(sessionLenBytes.buffer);
            sessionLenView.setUint32(0, 0, false);
        }
        
        // 4. Payload size (4 bytes, big endian)
        const payloadSizeBytes = new Uint8Array(4);
        const payloadSizeView = new DataView(payloadSizeBytes.buffer);
        payloadSizeView.setUint32(0, payloadBytes.length, false);
        
        // ÂêàÂπ∂ÊâÄÊúâÈÉ®ÂàÜ
        const totalLength = header.length + eventBytes.length + sessionLenBytes.length + sessionIdBytes.length + payloadSizeBytes.length + payloadBytes.length;
        const result = new Uint8Array(totalLength);
        let offset = 0;
        
        result.set(header, offset);
        offset += header.length;
        
        result.set(eventBytes, offset);
        offset += eventBytes.length;
        
        result.set(sessionLenBytes, offset);
        offset += sessionLenBytes.length;
        
        if (sessionIdBytes.length > 0) {
            result.set(sessionIdBytes, offset);
            offset += sessionIdBytes.length;
        }
        
        result.set(payloadSizeBytes, offset);
        offset += payloadSizeBytes.length;
        
        result.set(payloadBytes, offset);
        
        // Âè™ËÆ∞ÂΩïÈùûÈü≥È¢ëÊ∂àÊÅØÁöÑÁºñÁ†Å‰ø°ÊÅØ
        if (eventId !== 200) {
            console.log('ÁºñÁ†ÅÂÆåÊàêÔºåÊÄªÈïøÂ∫¶:', totalLength, 'ÂéãÁº©ÂêépayloadÈïøÂ∫¶:', payloadBytes.length);
        }
        return result.buffer;
    }
    
    // ÁÆÄÂåñÁöÑgzipÂéãÁº©ÂÆûÁé∞
    async gzipCompress(data) {
        try {
            const stream = new CompressionStream('gzip');
            const writer = stream.writable.getWriter();
            const reader = stream.readable.getReader();
            
            writer.write(data);
            writer.close();
            
            const chunks = [];
            let done = false;
            while (!done) {
                const { value, done: readerDone } = await reader.read();
                done = readerDone;
                if (value) {
                    chunks.push(value);
                }
            }
            
            // ÂêàÂπ∂ÊâÄÊúâchunks
            const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
            const result = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of chunks) {
                result.set(chunk, offset);
                offset += chunk.length;
            }
            
            return result;
        } catch (error) {
            console.error('GZIPÂéãÁº©Â§±Ë¥•:', error);
            return new Uint8Array(data);
        }
    }
    
    // GZIPËß£ÂéãÁº©
    async gzipDecompress(data) {
        try {
            const stream = new DecompressionStream('gzip');
            const writer = stream.writable.getWriter();
            const reader = stream.readable.getReader();
            
            writer.write(data);
            writer.close();
            
            const chunks = [];
            let done = false;
            while (!done) {
                const { value, done: readerDone } = await reader.read();
                done = readerDone;
                if (value) {
                    chunks.push(value);
                }
            }
            
            const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
            const result = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of chunks) {
                result.set(chunk, offset);
                offset += chunk.length;
            }
            
            return result;
        } catch (error) {
            console.error('GZIPËß£ÂéãÁº©Â§±Ë¥•:', error);
            return data;
        }
    }
    
    parseResponse(buffer) {
        // ÂáèÂ∞ëÊó•ÂøóËæìÂá∫È¢ëÁéá
        if (Math.random() < 0.1) { // Âè™ËÆ∞ÂΩï10%ÁöÑÂìçÂ∫î
            console.log('Ëß£ÊûêÂìçÂ∫îÔºåÈïøÂ∫¶:', buffer.byteLength);
        }
        
        const view = new DataView(buffer);
        const uint8View = new Uint8Array(buffer);
        
        // Header (4 bytes)
        const protocolVersion = (uint8View[0] >> 4) & 0x0F;
        const headerSize = uint8View[0] & 0x0F;
        const messageType = (uint8View[1] >> 4) & 0x0F;
        const flags = uint8View[1] & 0x0F;
        const serialization = (uint8View[2] >> 4) & 0x0F;
        const compression = uint8View[2] & 0x0F;
        
        let offset = headerSize * 4;
        let eventId = null;
        let sessionId = null;
        
        // Parse event ID
        if (flags & 0x04) {
            eventId = view.getUint32(offset, false); // Big endian
            offset += 4;
            // Âè™ËÆ∞ÂΩïÈáçË¶Å‰∫ã‰ª∂ID
            if (eventId !== 200 && eventId !== 352) {
                console.log('‰∫ã‰ª∂ID:', eventId);
            }
        }
        
        // Parse session ID
        if (offset < buffer.byteLength - 4) {
            const sessionIdLength = view.getUint32(offset, false);
            offset += 4;
            if (sessionIdLength > 0 && sessionIdLength < 1000) { // ÂêàÁêÜÊÄßÊ£ÄÊü•
                const decoder = new TextDecoder();
                sessionId = decoder.decode(uint8View.slice(offset, offset + sessionIdLength));
                offset += sessionIdLength;
                console.log('‰ºöËØùID:', sessionId);
            }
        }
        
        // Parse payload
        if (offset < buffer.byteLength - 4) {
            const payloadSize = view.getUint32(offset, false);
            offset += 4;
            console.log('PayloadÂ§ßÂ∞è:', payloadSize);
            
            if (payloadSize > 0 && offset + payloadSize <= buffer.byteLength) {
                const payload = uint8View.slice(offset, offset + payloadSize);
                
                return {
                    messageType,
                    eventId,
                    sessionId,
                    payload,
                    compression,
                    serialization
                };
            }
        }
        
        return {
            messageType,
            eventId,
            sessionId,
            payload: new Uint8Array(0),
            compression,
            serialization
        };
    }
    
    async handleMessage(data) {
        try {
            const message = this.parseResponse(data);
            console.log('Â§ÑÁêÜÊ∂àÊÅØ:', message);
            
            // Â§ÑÁêÜÂéãÁº©ÁöÑpayload
            if (message.compression === 0x01 && message.payload.length > 0) {
                try {
                    message.payload = await this.gzipDecompress(message.payload);
                    console.log('Ëß£ÂéãÁº©ÂêépayloadÈïøÂ∫¶:', message.payload.length);
                } catch (e) {
                    console.error('Ëß£ÂéãÁº©Â§±Ë¥•:', e);
                }
            }
            
            // Â§ÑÁêÜJSON payload
            if (message.serialization === 0x01 && message.payload.length > 0) {
                try {
                    const decoder = new TextDecoder();
                    const jsonStr = decoder.decode(message.payload);
                    console.log('JSONÂ≠óÁ¨¶‰∏≤:', jsonStr);
                    message.payload = JSON.parse(jsonStr);
                    
                    // Ê£ÄÊü•ÊòØÂê¶ÊúâÈîôËØØ‰ø°ÊÅØ
                    if (message.payload.error) {
                        console.error('ÊúçÂä°Âô®ËøîÂõûÈîôËØØ:', message.payload.error);
                        if (message.payload.error.includes('non-exist session')) {
                            console.log('‰ºöËØù‰∏çÂ≠òÂú®ÔºåÂ∞ùËØïÈáçÊñ∞ÂºÄÂßã‰ºöËØù');
                            this.handleSessionError();
                            return;
                        }
                    }
                } catch (e) {
                    console.error('JSONËß£ÊûêÂ§±Ë¥•:', e);
                }
            }
            
            // Â§ÑÁêÜ‰∏çÂêå‰∫ã‰ª∂
            if (message.eventId) {
                switch (message.eventId) {
                    case 50: // CONNECTION_STARTED
                        console.log('ËøûÊé•Â∑≤Âª∫Á´ã');
                        this.updateStatus('ËøûÊé•Â∑≤Âª∫Á´ã');
                        this.startSession();
                        break;
                        
                    case 51: // CONNECTION_FAILED
                        console.log('ËøûÊé•Â§±Ë¥•:', message.payload);
                        this.updateStatus('ËøûÊé•Â§±Ë¥•');
                        break;
                        
                    case 150: // SESSION_STARTED
                        console.log('‰ºöËØùÂ∑≤ÂºÄÂßã:', message.payload);
                        // ‰øùÊåÅÂéüÊúâÁöÑsessionIdÔºå‰∏çË¶ÅÊîπÂèòÂÆÉ
                        if (message.payload?.dialog_id) {
                            console.log('ÊúçÂä°Âô®ËøîÂõûÁöÑdialog_id:', message.payload.dialog_id);
                            console.log('ÂΩìÂâç‰ΩøÁî®ÁöÑsessionId:', this.sessionId);
                        }
                        this.updateStatus('ÈÄöËØù‰∏≠');
                        this.startCall();
                        const currentGf = AI_GIRLFRIENDS[this.currentGirlfriend];
                        const greetings = {
                            xiaoya: 'Âó®ÔΩûÊàëÊòØÂ∞èÈõÖÔºåÂæàÈ´òÂÖ¥Âê¨Âà∞‰Ω†ÁöÑÂ£∞Èü≥Âë¢ÔºÅüíï',
                            xiaoyue: 'ÂìáÔºÅÊòØ‰Ω†ÂëÄÔºÅÊàëÊòØÂ∞èÊÇ¶ÔºåÂ•ΩÂºÄÂøÉËÉΩÂíå‰Ω†ËÅäÂ§©ÔºÅüå∏‚ú®',
                            xiaojing: '‰Ω†Â•ΩÔºåÊàëÊòØÂ∞èÈùô„ÄÇÂæàÈ´òÂÖ¥ËÉΩ‰∏é‰Ω†ËøõË°åËøôÊ¨°ÂØπËØù„ÄÇüìö',
                            xiaomeng: 'Âì•Âì•ÔΩû‰∫∫ÂÆ∂ÊòØÂ∞èËêåÂìíÔºÅÂ•ΩÊÉ≥ÂíåÂì•Âì•ËØ¥ËØùÂë¢ÔΩûüéÄ',
                            xiaoku: 'ÊàëÊòØÂ∞èÈÖ∑...Êúâ‰ªÄ‰πà‰∫ãÂêóÔºüüòé'
                        };
                        this.addMessage('bot', greetings[this.currentGirlfriend] || greetings.xiaoya);
                        break;
                        
                    case 153: // SESSION_FAILED
                        console.log('‰ºöËØùÂ§±Ë¥•:', message.payload);
                        this.updateStatus('‰ºöËØùÂ§±Ë¥•');
                        break;
                        
                    case 350: // TTS_SENTENCE_START
                        console.log('TTSÂºÄÂßã');
                        document.getElementById('avatar').classList.add('speaking');
                        break;
                        
                    case 352: // TTS_RESPONSE
                        console.log('Êî∂Âà∞TTSÈü≥È¢ëÊï∞ÊçÆ, messageType:', message.messageType);
                        // TTSÈü≥È¢ëÊï∞ÊçÆÔºåÁõ¥Êé•Êí≠Êîæ
                        if (message.payload && message.payload.length > 0) {
                            this.playAudio(message.payload.buffer || message.payload);
                        } else {
                            console.log('TTSÈü≥È¢ëÊï∞ÊçÆ‰∏∫Á©∫');
                        }
                        break;
                        
                    case 359: // TTS_ENDED
                        console.log('TTSÁªìÊùü');
                        document.getElementById('avatar').classList.remove('speaking');
                        break;
                        
                    case 451: // ASR_RESPONSE
                        console.log('ASRËØÜÂà´ÁªìÊûú:', message.payload);
                        if (message.payload?.results) {
                            const results = message.payload.results;
                            if (results.length > 0 && !results[0].is_interim) {
                                this.addMessage('user', results[0].text);
                            }
                        }
                        break;
                        
                    case 550: // CHAT_RESPONSE
                        console.log('ËÅäÂ§©ÂõûÂ§ç:', message.payload);
                        if (message.payload?.content) {
                            this.addMessage('bot', message.payload.content);
                        }
                        break;
                        
                    case 551: // CHAT_FINISHED ÊàñÂÖ∂‰ªñËÅäÂ§©Áõ∏ÂÖ≥‰∫ã‰ª∂
                        console.log('ËÅäÂ§©ÂÆåÊàê‰∫ã‰ª∂:', message.payload);
                        if (message.payload?.content) {
                            this.addMessage('bot', message.payload.content);
                        }
                        break;
                        
                    case 250: // ÂèØËÉΩÁöÑÂØπËØùÂõûÂ§ç‰∫ã‰ª∂
                    case 251:
                    case 252:
                        console.log('ÂØπËØù‰∫ã‰ª∂:', message.eventId, message.payload);
                        if (message.payload?.content || message.payload?.text) {
                            this.addMessage('bot', message.payload.content || message.payload.text);
                        }
                        break;
                        
                    default:
                        // ËÆ∞ÂΩïÊâÄÊúâÊú™Â§ÑÁêÜÁöÑ‰∫ã‰ª∂ÔºåÂ∏ÆÂä©Ë∞ÉËØï
                        console.log('Êú™Â§ÑÁêÜÁöÑ‰∫ã‰ª∂:', message.eventId, message.payload);
                        
                        // Â¶ÇÊûúpayloadÂåÖÂê´ÊñáÊú¨ÂÜÖÂÆπÔºåÂ∞ùËØïÊòæÁ§∫
                        if (message.payload && typeof message.payload === 'object') {
                            if (message.payload.content) {
                                console.log('ÂèëÁé∞Êú™Áü•‰∫ã‰ª∂‰∏≠ÁöÑcontent:', message.payload.content);
                                this.addMessage('bot', message.payload.content);
                            } else if (message.payload.text) {
                                console.log('ÂèëÁé∞Êú™Áü•‰∫ã‰ª∂‰∏≠ÁöÑtext:', message.payload.text);
                                this.addMessage('bot', message.payload.text);
                            }
                        }
                }
            }
            
        } catch (error) {
            console.error('Â§ÑÁêÜÊ∂àÊÅØÂ§±Ë¥•:', error);
        }
    }
    
    async sendStartConnection() {
        console.log('ÂèëÈÄÅStartConnection‰∫ã‰ª∂');
        const message = await this.encodeMessage(1, '{}'); // START_CONNECTION = 1
        this.ws.send(message);
        return Promise.resolve(); // ËøîÂõûPromise‰ª•ÊîØÊåÅthenË∞ÉÁî®
    }
    
    async startSession() {
        console.log('ÂºÄÂßã‰ºöËØù');
        this.sessionId = this.generateUUID();
        
        const currentGf = AI_GIRLFRIENDS[this.currentGirlfriend];
        const customPrompt = document.getElementById('promptEditor')?.value.trim();
        
        // Â¶ÇÊûúÊúâËá™ÂÆö‰πâÊèêÁ§∫ËØçÔºå‰ΩøÁî®Ëá™ÂÆö‰πâÁöÑÔºåÂê¶Âàô‰ΩøÁî®È¢ÑËÆæ
        let systemRole, speakingStyle;
        if (customPrompt && customPrompt !== `${currentGf.systemRole}\n\n${currentGf.speakingStyle}`) {
            // Ëá™ÂÆö‰πâÊèêÁ§∫ËØçÔºåÂ∞ùËØïÂàÜÁ¶ªÁ≥ªÁªüËßíËâ≤ÂíåËØ¥ËØùÈ£éÊ†º
            const parts = customPrompt.split('\n\n');
            systemRole = parts[0] || currentGf.systemRole;
            speakingStyle = parts[1] || currentGf.speakingStyle;
        } else {
            systemRole = currentGf.systemRole;
            speakingStyle = currentGf.speakingStyle;
        }
        
        const sessionData = {
            tts: {
                audio_config: {
                    channel: 1,
                    format: "pcm",
                    sample_rate: 24000
                }
            },
            dialog: {
                bot_name: "Â∞èÈõÖ", // Áªü‰∏Ä‰ΩøÁî®Â∞èÈõÖÔºåÈÄöËøásystem_roleÂå∫ÂàÜÊÄßÊ†º
                system_role: systemRole,
                speaking_style: speakingStyle,
                extra: {
                    strict_audit: false,
                    audit_response: "Êä±Ê≠âÔºåÊàë‰∏çÂ§™ÊòéÁôΩ‰Ω†ËØ¥ÁöÑËØùÔºåÊàë‰ª¨ËÅäÁÇπÂà´ÁöÑÂêßÔΩû"
                }
            }
        };
        
        const message = await this.encodeMessage(100, JSON.stringify(sessionData), this.sessionId); // START_SESSION = 100
        this.ws.send(message);
    }
    
    async sendAudio(audioData) {
        if (!this.isConnected || !this.sessionId || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
            return;
        }
        
        try {
            const message = await this.encodeMessage(200, audioData, this.sessionId, 0x02); // TASK_REQUEST = 200, Audio message type = 0x02
            this.ws.send(message);
        } catch (error) {
            console.error('ÂèëÈÄÅÈü≥È¢ëÊï∞ÊçÆÂ§±Ë¥•:', error);
        }
    }
    
    async playAudio(audioBuffer) {
        try {
            if (!this.audioContext || !audioBuffer) {
                console.log('Êí≠ÊîæÈü≥È¢ëÂ§±Ë¥•ÔºöaudioContextÊàñaudioBuffer‰∏∫Á©∫');
                return;
            }
            
            // Á°Æ‰øùaudioBufferÊòØArrayBufferÁ±ªÂûã
            let buffer = audioBuffer;
            if (audioBuffer.buffer) {
                buffer = audioBuffer.buffer;
            }
            
            console.log('Â∞ùËØïÊí≠ÊîæÈü≥È¢ëÔºåÈïøÂ∫¶:', buffer.byteLength);
            
            if (buffer.byteLength < 8) {
                console.log('Èü≥È¢ëÊï∞ÊçÆÂ§™Áü≠ÔºåË∑≥ËøáÊí≠Êîæ');
                return;
            }
            
            // Â∞ùËØïÁõ¥Êé•Ëß£Á†ÅÔºàÂ¶ÇÊûúÊòØÊ†áÂáÜÈü≥È¢ëÊ†ºÂºèÔºâ
            try {
                const audioData = await this.audioContext.decodeAudioData(buffer.slice());
                const source = this.audioContext.createBufferSource();
                source.buffer = audioData;
                source.connect(this.audioContext.destination);
                source.start();
                console.log('Ê†áÂáÜÈü≥È¢ëÊ†ºÂºèÊí≠ÊîæÊàêÂäü');
                return;
            } catch (e) {
                console.log('Ê†áÂáÜÊ†ºÂºèËß£Á†ÅÂ§±Ë¥•ÔºåÂ∞ùËØïPCM:', e.message);
            }
            
            // Â∞ùËØï‰Ωú‰∏∫PCMÊï∞ÊçÆÂ§ÑÁêÜ (24kHz, Float32)
            const view = new DataView(buffer);
            const sampleCount = buffer.byteLength / 4;
            
            if (sampleCount > 0) {
                const audioData = this.audioContext.createBuffer(1, sampleCount, 24000);
                const channelData = audioData.getChannelData(0);
                
                for (let i = 0; i < sampleCount; i++) {
                    channelData[i] = view.getFloat32(i * 4, true);
                }
                
                const source = this.audioContext.createBufferSource();
                source.buffer = audioData;
                source.connect(this.audioContext.destination);
                source.start();
                console.log('PCMÈü≥È¢ëÊí≠ÊîæÊàêÂäü');
            }
            
        } catch (error) {
            console.error('Êí≠ÊîæÈü≥È¢ëÂ§±Ë¥•:', error.message);
        }
    }
    
    startCall() {
        console.log('ÂºÄÂßãÈÄöËØù');
        this.isInCall = true;
        this.callStartTime = Date.now();
        
        const callBtn = document.getElementById('callBtn');
        callBtn.classList.add('calling');
        callBtn.innerHTML = 'üìû';
        
        document.getElementById('callStatus').textContent = 'ÈÄöËØù‰∏≠';
        document.getElementById('callInfo').textContent = 'Ê≠£Âú®ÈÄöËØù...';
        
        this.startCallTimer();
        this.startContinuousRecording();
    }
    
    endCall() {
        console.log('ÁªìÊùüÈÄöËØù');
        this.isInCall = false;
        this.isRecording = false;
        
        if (this.callTimer) {
            clearInterval(this.callTimer);
            this.callTimer = null;
        }
        
        const callBtn = document.getElementById('callBtn');
        callBtn.classList.remove('calling');
        callBtn.innerHTML = 'üìû';
        
        document.getElementById('callStatus').textContent = 'ÈÄöËØùÁªìÊùü';
        document.getElementById('callInfo').textContent = 'Â∞èÈõÖÂú®Á∫øÔºåÈöèÊó∂‰∏∫‰Ω†ÊúçÂä°üíï';
        document.getElementById('callDuration').textContent = '00:00';
        
        if (this.audioProcessor) {
            this.audioProcessor.disconnect();
            this.audioProcessor = null;
        }
        
        if (this.isConnected && this.sessionId) {
            this.sendFinishSession();
        }
    }
    
    startCallTimer() {
        this.callTimer = setInterval(() => {
            if (this.callStartTime) {
                const elapsed = Math.floor((Date.now() - this.callStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = (elapsed % 60).toString().padStart(2, '0');
                document.getElementById('callDuration').textContent = `${minutes}:${seconds}`;
            }
        }, 1000);
    }
    
    startContinuousRecording() {
        if (!this.isConnected || !this.isInCall) return;
        
        console.log('ÂºÄÂßãÂΩïÈü≥');
        this.isRecording = true;
        this.audioBuffer = [];
        this.bufferSize = 0;
        this.targetBufferSize = 8000; // 500ms at 16kHz - Â§ßÂπÖÂáèÂ∞ëÂèëÈÄÅÈ¢ëÁéá
        this.lastSendTime = 0;
        this.minSendInterval = 300; // ÊúÄÂ∞èÂèëÈÄÅÈó¥Èöî300ms
        
        if (this.audioContext.state === 'suspended') {
            this.audioContext.resume();
        }
        
        this.audioProcessor = this.audioContext.createScriptProcessor(1024, 1, 1);
        const source = this.audioContext.createMediaStreamSource(this.stream);
        
        source.connect(this.audioProcessor);
        this.audioProcessor.connect(this.audioContext.destination);
        
        this.audioProcessor.onaudioprocess = (event) => {
            if (!this.isInCall || this.isMuted) return;
            
            const inputBuffer = event.inputBuffer;
            const inputData = inputBuffer.getChannelData(0);
            
            // Ê£ÄÊµãÈü≥È¢ëÊ¥ªÂä®Â∫¶
            const audioLevel = this.getAudioLevel(inputData);
            
            // Âè™ÊúâÂú®ÊúâË∂≥Â§üÈü≥È¢ëÊ¥ªÂä®Êó∂ÊâçÂ§ÑÁêÜ
            if (audioLevel > 0.01) {
                const pcmData = this.convertToPCM16(inputData);
                this.audioBuffer.push(pcmData);
                this.bufferSize += pcmData.length;
            }
            
            // Ê£ÄÊü•ÊòØÂê¶Â∫îËØ•ÂèëÈÄÅÔºàÊó∂Èó¥ÂíåÂ§ßÂ∞èÊù°‰ª∂Ôºâ
            const now = Date.now();
            const shouldSend = (
                this.bufferSize >= this.targetBufferSize || 
                (this.bufferSize > 1600 && now - this.lastSendTime > this.minSendInterval)
            );
            
            if (shouldSend && now - this.lastSendTime > this.minSendInterval) {
                this.flushAudioBuffer();
                this.lastSendTime = now;
            }
        };
        
        this.setupVolumeIndicator();
    }
    
    getAudioLevel(samples) {
        let sum = 0;
        for (let i = 0; i < samples.length; i++) {
            sum += Math.abs(samples[i]);
        }
        return sum / samples.length;
    }
    
    flushAudioBuffer() {
        if (this.audioBuffer.length === 0) return;
        
        // ÂêàÂπ∂ÊâÄÊúâÁºìÂÜ≤ÁöÑÈü≥È¢ëÊï∞ÊçÆ
        const totalSize = this.audioBuffer.reduce((sum, buffer) => sum + buffer.length, 0);
        const combinedBuffer = new Uint8Array(totalSize);
        let offset = 0;
        
        for (const buffer of this.audioBuffer) {
            combinedBuffer.set(buffer, offset);
            offset += buffer.length;
        }
        
        // ÂèëÈÄÅÂêàÂπ∂ÂêéÁöÑÈü≥È¢ëÊï∞ÊçÆ
        this.sendAudio(combinedBuffer.buffer);
        
        // Ê∏ÖÁ©∫ÁºìÂÜ≤Âå∫
        this.audioBuffer = [];
        this.bufferSize = 0;
    }
    
    convertToPCM16(float32Array) {
        const buffer = new ArrayBuffer(float32Array.length * 2);
        const view = new DataView(buffer);
        let offset = 0;
        
        for (let i = 0; i < float32Array.length; i++, offset += 2) {
            let sample = Math.max(-1, Math.min(1, float32Array[i]));
            sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
            view.setInt16(offset, sample, true);
        }
        
        return new Uint8Array(buffer);
    }
    
    async sendFinishSession() {
        console.log('ÂèëÈÄÅFinishSession‰∫ã‰ª∂');
        const message = await this.encodeMessage(102, '{}', this.sessionId); // FINISH_SESSION = 102
        this.ws.send(message);
    }
    
    handleSessionError() {
        console.log('Â§ÑÁêÜ‰ºöËØùÈîôËØØÔºåÈáçÊñ∞ÂºÄÂßã‰ºöËØù');
        this.updateStatus('ÈáçÊñ∞ËøûÊé•‰∏≠...');
        
        // ÂÅúÊ≠¢ÂΩìÂâçÂΩïÈü≥
        if (this.audioProcessor) {
            this.audioProcessor.disconnect();
            this.audioProcessor = null;
        }
        
        // ÈáçÊñ∞ÁîüÊàê‰ºöËØùIDÂíåËøûÊé•ID
        this.sessionId = this.generateUUID();
        this.connectId = this.generateUUID();
        
        // Â¶ÇÊûúWebSocketËøûÊé•ÊúâÈóÆÈ¢òÔºåÈáçÊñ∞ËøûÊé•
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            console.log('WebSocketËøûÊé•ÂºÇÂ∏∏ÔºåÈáçÊñ∞ËøûÊé•');
            this.isConnected = false;
            this.connect();
            return;
        }
        
        // Âª∂Ëøü‰∏Ä‰∏ãÂÜçÈáçÊñ∞ÂºÄÂßã‰ºöËØù
        setTimeout(() => {
            if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
                // ÂÖàÂèëÈÄÅStartConnectionÂÜçÂºÄÂßã‰ºöËØù
                this.sendStartConnection().then(() => {
                    setTimeout(() => {
                        this.startSession();
                    }, 500);
                });
            } else {
                console.log('ËøûÊé•Áä∂ÊÄÅÂºÇÂ∏∏ÔºåÈáçÊñ∞ËøûÊé•');
                this.connect();
            }
        }, 1000);
    }
    
    addMessage(sender, text) {
        console.log(`Ê∑ªÂä†Ê∂àÊÅØ: ${sender}: ${text}`);
        const messagesContainer = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${sender}`;
        messageDiv.textContent = text;
        messagesContainer.appendChild(messageDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    updateStatus(status) {
        console.log('Áä∂ÊÄÅÊõ¥Êñ∞:', status);
        const statusElement = document.getElementById('status');
        statusElement.textContent = status;
        
        statusElement.className = 'status';
        if (status.includes('Â∑≤ËøûÊé•') || status.includes('ÈÄöËØù‰∏≠')) {
            statusElement.style.background = 'rgba(0, 255, 136, 0.2)';
            statusElement.style.color = '#00ff88';
            statusElement.style.borderColor = 'rgba(0, 255, 136, 0.3)';
        } else if (status.includes('ËøûÊé•‰∏≠') || status.includes('ÂáÜÂ§á')) {
            statusElement.style.background = 'rgba(255, 193, 160, 0.2)';
            statusElement.style.color = '#ffc3a0';
            statusElement.style.borderColor = 'rgba(255, 193, 160, 0.3)';
        } else {
            statusElement.style.background = 'rgba(255, 71, 87, 0.2)';
            statusElement.style.color = '#ff4757';
            statusElement.style.borderColor = 'rgba(255, 71, 87, 0.3)';
        }
    }
}

// ÂÖ®Â±ÄÂèòÈáèÂíåÂáΩÊï∞
let client = new RealtimeClient();

function toggleCall() {
    console.log('ÂàáÊç¢ÈÄöËØùÁä∂ÊÄÅÔºåÂΩìÂâçÁä∂ÊÄÅ:', client.isInCall);
    if (!client.isInCall) {
        if (!client.isConnected) {
            client.connect();
        } else {
            client.startSession();
        }
    } else {
        client.endCall();
    }
}

function toggleMute() {
    client.isMuted = !client.isMuted;
    const muteBtn = document.getElementById('muteBtn');
    muteBtn.innerHTML = client.isMuted ? 'üîá' : 'üé§';
    muteBtn.title = client.isMuted ? 'ÂèñÊ∂àÈùôÈü≥' : 'ÈùôÈü≥';
    console.log('ÈùôÈü≥Áä∂ÊÄÅ:', client.isMuted);
}

function toggleSpeaker() {
    const speakerBtn = document.getElementById('speakerBtn');
    speakerBtn.innerHTML = speakerBtn.innerHTML === 'üì¢' ? 'üîä' : 'üì¢';
}

// Êñ∞Â¢ûÁöÑÂÖ®Â±ÄÂáΩÊï∞
function toggleLeftPanel() {
    const panel = document.getElementById('leftPanel');
    panel.classList.toggle('collapsed');
}

function savePrompt() {
    const editor = document.getElementById('promptEditor');
    const currentGf = AI_GIRLFRIENDS[client.currentGirlfriend];
    
    if (editor && editor.value.trim()) {
        // ÂèØ‰ª•Âú®ËøôÈáåÊ∑ªÂä†‰øùÂ≠òÂà∞localStorageÁöÑÈÄªËæë
        console.log('‰øùÂ≠òËá™ÂÆö‰πâÊèêÁ§∫ËØç:', editor.value);
        
        // ÊòæÁ§∫‰øùÂ≠òÊàêÂäüÊèêÁ§∫
        const btn = document.querySelector('.save-btn');
        const originalText = btn.textContent;
        btn.textContent = 'Â∑≤‰øùÂ≠òÔºÅ';
        btn.style.background = 'linear-gradient(135deg, #ff6b9d, #ffc3a0)';
        
        setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = 'linear-gradient(135deg, #00ff88, #00cc6a)';
        }, 2000);
        
        // Â¶ÇÊûúÊ≠£Âú®ÈÄöËØùÔºåÊèêÁ§∫Áî®Êà∑ÈáçÊñ∞ÂºÄÂßã
        if (client.isInCall) {
            client.addMessage('system', 'Â∑≤‰øùÂ≠òËÆæÁΩÆÔºåËØ∑ÈáçÊñ∞ÂºÄÂßãÈÄöËØù‰ª•Â∫îÁî®Êñ∞ÁöÑÊèêÁ§∫ËØç');
        }
    }
}

// È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéÂàùÂßãÂåñ
document.addEventListener('DOMContentLoaded', function() {
    console.log('È°µÈù¢Âä†ËΩΩÂÆåÊàêÔºåÂÆ¢Êà∑Á´ØÂàùÂßãÂåñ');
    
    // Ê∑ªÂä†ÂÖ®Â±ÄÈîôËØØÂ§ÑÁêÜ
    window.addEventListener('error', function(e) {
        console.error('ÂÖ®Â±ÄÈîôËØØ:', e.error);
    });
    
    window.addEventListener('unhandledrejection', function(e) {
        console.error('Êú™Â§ÑÁêÜÁöÑPromiseÊãíÁªù:', e.reason);
    });
});